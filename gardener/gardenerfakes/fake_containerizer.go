// This file was generated by counterfeiter
package gardenerfakes

import (
	"io"
	"sync"

	"code.cloudfoundry.org/garden"
	"code.cloudfoundry.org/guardian/gardener"
	"code.cloudfoundry.org/lager"
)

type FakeContainerizer struct {
	CreateStub        func(log lager.Logger, spec gardener.DesiredContainerSpec) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		log  lager.Logger
		spec gardener.DesiredContainerSpec
	}
	createReturns struct {
		result1 error
	}
	HandlesStub        func() ([]string, error)
	handlesMutex       sync.RWMutex
	handlesArgsForCall []struct{}
	handlesReturns     struct {
		result1 []string
		result2 error
	}
	StreamInStub        func(log lager.Logger, handle string, spec garden.StreamInSpec) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		log    lager.Logger
		handle string
		spec   garden.StreamInSpec
	}
	streamInReturns struct {
		result1 error
	}
	StreamOutStub        func(log lager.Logger, handle string, spec garden.StreamOutSpec) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		log    lager.Logger
		handle string
		spec   garden.StreamOutSpec
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	RunStub        func(log lager.Logger, handle string, spec garden.ProcessSpec, io garden.ProcessIO) (garden.Process, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		log    lager.Logger
		handle string
		spec   garden.ProcessSpec
		io     garden.ProcessIO
	}
	runReturns struct {
		result1 garden.Process
		result2 error
	}
	AttachStub        func(log lager.Logger, handle string, processGUID string, io garden.ProcessIO) (garden.Process, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		log         lager.Logger
		handle      string
		processGUID string
		io          garden.ProcessIO
	}
	attachReturns struct {
		result1 garden.Process
		result2 error
	}
	StopStub        func(log lager.Logger, handle string, kill bool) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		log    lager.Logger
		handle string
		kill   bool
	}
	stopReturns struct {
		result1 error
	}
	DestroyStub        func(log lager.Logger, handle string) error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		log    lager.Logger
		handle string
	}
	destroyReturns struct {
		result1 error
	}
	RemoveBundleStub        func(log lager.Logger, handle string) error
	removeBundleMutex       sync.RWMutex
	removeBundleArgsForCall []struct {
		log    lager.Logger
		handle string
	}
	removeBundleReturns struct {
		result1 error
	}
	InfoStub        func(log lager.Logger, handle string) (gardener.ActualContainerSpec, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		log    lager.Logger
		handle string
	}
	infoReturns struct {
		result1 gardener.ActualContainerSpec
		result2 error
	}
	MetricsStub        func(log lager.Logger, handle string) (gardener.ActualContainerMetrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct {
		log    lager.Logger
		handle string
	}
	metricsReturns struct {
		result1 gardener.ActualContainerMetrics
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerizer) Create(log lager.Logger, spec gardener.DesiredContainerSpec) error {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		log  lager.Logger
		spec gardener.DesiredContainerSpec
	}{log, spec})
	fake.recordInvocation("Create", []interface{}{log, spec})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(log, spec)
	} else {
		return fake.createReturns.result1
	}
}

func (fake *FakeContainerizer) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeContainerizer) CreateArgsForCall(i int) (lager.Logger, gardener.DesiredContainerSpec) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].log, fake.createArgsForCall[i].spec
}

func (fake *FakeContainerizer) CreateReturns(result1 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerizer) Handles() ([]string, error) {
	fake.handlesMutex.Lock()
	fake.handlesArgsForCall = append(fake.handlesArgsForCall, struct{}{})
	fake.recordInvocation("Handles", []interface{}{})
	fake.handlesMutex.Unlock()
	if fake.HandlesStub != nil {
		return fake.HandlesStub()
	} else {
		return fake.handlesReturns.result1, fake.handlesReturns.result2
	}
}

func (fake *FakeContainerizer) HandlesCallCount() int {
	fake.handlesMutex.RLock()
	defer fake.handlesMutex.RUnlock()
	return len(fake.handlesArgsForCall)
}

func (fake *FakeContainerizer) HandlesReturns(result1 []string, result2 error) {
	fake.HandlesStub = nil
	fake.handlesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) StreamIn(log lager.Logger, handle string, spec garden.StreamInSpec) error {
	fake.streamInMutex.Lock()
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		log    lager.Logger
		handle string
		spec   garden.StreamInSpec
	}{log, handle, spec})
	fake.recordInvocation("StreamIn", []interface{}{log, handle, spec})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(log, handle, spec)
	} else {
		return fake.streamInReturns.result1
	}
}

func (fake *FakeContainerizer) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeContainerizer) StreamInArgsForCall(i int) (lager.Logger, string, garden.StreamInSpec) {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return fake.streamInArgsForCall[i].log, fake.streamInArgsForCall[i].handle, fake.streamInArgsForCall[i].spec
}

func (fake *FakeContainerizer) StreamInReturns(result1 error) {
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerizer) StreamOut(log lager.Logger, handle string, spec garden.StreamOutSpec) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		log    lager.Logger
		handle string
		spec   garden.StreamOutSpec
	}{log, handle, spec})
	fake.recordInvocation("StreamOut", []interface{}{log, handle, spec})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(log, handle, spec)
	} else {
		return fake.streamOutReturns.result1, fake.streamOutReturns.result2
	}
}

func (fake *FakeContainerizer) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeContainerizer) StreamOutArgsForCall(i int) (lager.Logger, string, garden.StreamOutSpec) {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return fake.streamOutArgsForCall[i].log, fake.streamOutArgsForCall[i].handle, fake.streamOutArgsForCall[i].spec
}

func (fake *FakeContainerizer) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) Run(log lager.Logger, handle string, spec garden.ProcessSpec, io garden.ProcessIO) (garden.Process, error) {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		log    lager.Logger
		handle string
		spec   garden.ProcessSpec
		io     garden.ProcessIO
	}{log, handle, spec, io})
	fake.recordInvocation("Run", []interface{}{log, handle, spec, io})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(log, handle, spec, io)
	} else {
		return fake.runReturns.result1, fake.runReturns.result2
	}
}

func (fake *FakeContainerizer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainerizer) RunArgsForCall(i int) (lager.Logger, string, garden.ProcessSpec, garden.ProcessIO) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return fake.runArgsForCall[i].log, fake.runArgsForCall[i].handle, fake.runArgsForCall[i].spec, fake.runArgsForCall[i].io
}

func (fake *FakeContainerizer) RunReturns(result1 garden.Process, result2 error) {
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) Attach(log lager.Logger, handle string, processGUID string, io garden.ProcessIO) (garden.Process, error) {
	fake.attachMutex.Lock()
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		log         lager.Logger
		handle      string
		processGUID string
		io          garden.ProcessIO
	}{log, handle, processGUID, io})
	fake.recordInvocation("Attach", []interface{}{log, handle, processGUID, io})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(log, handle, processGUID, io)
	} else {
		return fake.attachReturns.result1, fake.attachReturns.result2
	}
}

func (fake *FakeContainerizer) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeContainerizer) AttachArgsForCall(i int) (lager.Logger, string, string, garden.ProcessIO) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return fake.attachArgsForCall[i].log, fake.attachArgsForCall[i].handle, fake.attachArgsForCall[i].processGUID, fake.attachArgsForCall[i].io
}

func (fake *FakeContainerizer) AttachReturns(result1 garden.Process, result2 error) {
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) Stop(log lager.Logger, handle string, kill bool) error {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		log    lager.Logger
		handle string
		kill   bool
	}{log, handle, kill})
	fake.recordInvocation("Stop", []interface{}{log, handle, kill})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(log, handle, kill)
	} else {
		return fake.stopReturns.result1
	}
}

func (fake *FakeContainerizer) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeContainerizer) StopArgsForCall(i int) (lager.Logger, string, bool) {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].log, fake.stopArgsForCall[i].handle, fake.stopArgsForCall[i].kill
}

func (fake *FakeContainerizer) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerizer) Destroy(log lager.Logger, handle string) error {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		log    lager.Logger
		handle string
	}{log, handle})
	fake.recordInvocation("Destroy", []interface{}{log, handle})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub(log, handle)
	} else {
		return fake.destroyReturns.result1
	}
}

func (fake *FakeContainerizer) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeContainerizer) DestroyArgsForCall(i int) (lager.Logger, string) {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return fake.destroyArgsForCall[i].log, fake.destroyArgsForCall[i].handle
}

func (fake *FakeContainerizer) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerizer) RemoveBundle(log lager.Logger, handle string) error {
	fake.removeBundleMutex.Lock()
	fake.removeBundleArgsForCall = append(fake.removeBundleArgsForCall, struct {
		log    lager.Logger
		handle string
	}{log, handle})
	fake.recordInvocation("RemoveBundle", []interface{}{log, handle})
	fake.removeBundleMutex.Unlock()
	if fake.RemoveBundleStub != nil {
		return fake.RemoveBundleStub(log, handle)
	} else {
		return fake.removeBundleReturns.result1
	}
}

func (fake *FakeContainerizer) RemoveBundleCallCount() int {
	fake.removeBundleMutex.RLock()
	defer fake.removeBundleMutex.RUnlock()
	return len(fake.removeBundleArgsForCall)
}

func (fake *FakeContainerizer) RemoveBundleArgsForCall(i int) (lager.Logger, string) {
	fake.removeBundleMutex.RLock()
	defer fake.removeBundleMutex.RUnlock()
	return fake.removeBundleArgsForCall[i].log, fake.removeBundleArgsForCall[i].handle
}

func (fake *FakeContainerizer) RemoveBundleReturns(result1 error) {
	fake.RemoveBundleStub = nil
	fake.removeBundleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerizer) Info(log lager.Logger, handle string) (gardener.ActualContainerSpec, error) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		log    lager.Logger
		handle string
	}{log, handle})
	fake.recordInvocation("Info", []interface{}{log, handle})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub(log, handle)
	} else {
		return fake.infoReturns.result1, fake.infoReturns.result2
	}
}

func (fake *FakeContainerizer) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeContainerizer) InfoArgsForCall(i int) (lager.Logger, string) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return fake.infoArgsForCall[i].log, fake.infoArgsForCall[i].handle
}

func (fake *FakeContainerizer) InfoReturns(result1 gardener.ActualContainerSpec, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 gardener.ActualContainerSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) Metrics(log lager.Logger, handle string) (gardener.ActualContainerMetrics, error) {
	fake.metricsMutex.Lock()
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct {
		log    lager.Logger
		handle string
	}{log, handle})
	fake.recordInvocation("Metrics", []interface{}{log, handle})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub(log, handle)
	} else {
		return fake.metricsReturns.result1, fake.metricsReturns.result2
	}
}

func (fake *FakeContainerizer) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeContainerizer) MetricsArgsForCall(i int) (lager.Logger, string) {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return fake.metricsArgsForCall[i].log, fake.metricsArgsForCall[i].handle
}

func (fake *FakeContainerizer) MetricsReturns(result1 gardener.ActualContainerMetrics, result2 error) {
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 gardener.ActualContainerMetrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerizer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.handlesMutex.RLock()
	defer fake.handlesMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.removeBundleMutex.RLock()
	defer fake.removeBundleMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeContainerizer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ gardener.Containerizer = new(FakeContainerizer)
